批处理优化思路：
1、健壮性：面的异常输入不崩（参数校验+异常抛出）
2、稳定性：
    避免长事物：分批
    重试：记录日志，而且要设置上限，可以使用Guava Retrying
    中断恢复：数据库宕机/服务重启等导致中断，增量恢复
3、性能优化：
    批量操作：mybatis提供saveBatch
    并发编程：利用并发包中的CompletableFuture+线程池来并发处理多个任务
    sql优化：最基本优化原则，不要使用”select *“查询，使用对应字段
    异步任务：将批量操作的处理变成提交一个后台任务，提交任务后接口可以直接给前端返回已提交的任务id。后台可以根据情况选择时机去执行之前提交的后台任务(比如通过定时任务或者消息队列)。前端可以通过轮询调用接口、Websocket、sSE等方式得知任务的执行进度。比如后端提供一个根据任务id查询
状态的接口
    数据库连接池调优：没必要每次都重连数据库，只需要在连接池里寻找和数据库连接的线程即可（HikariCP、Druid）
4、数据一致性：
    事务管理：使用了@Transactional(ro11backFor =Exception.class)来保证数据一致性。如果任意一步操作失败，整个事务会回滚
    并发管理：
        分布式锁：防止同一个接口(或方法)在同一时间被多个管理员同时操作，比如使用Redis +Redisson实现分布式锁
        如果要精细地对某个数据进行并发控制，可以选用乐观锁。比如通过给 QuestionBank表增加一个 version 字段，在更新时检查版本号是否一致，确保对同一个题库的并发操作不会相互干扰
5、可观测性：重点子在可见性（返回内部状态，如BatchAddResult）、追踪性（可定位）、诊断性（可快速诊断）
    日志记录：
    监控：对服务器、JVM、请求和组件进行监控，常用监控为Grafana、引入的组件一般会自带监控，数据库用Druid、Elasticsearch用Kibana、Spring Boot用Soring Boot Actuator
    返回值优化：自带一些信息，例如批处理中哪些任务失败  


批处理
spring事务注解“@Transaction”是基于代理实现的，通过生成this类的代理类来调用
想在当前类内使用“@Transaction”，需要获取代理类对象（AopContext.currentProxy），不能直接用this
 

并发编程
1、CompletableFuture默认使用的是ForkJoinPool.commonPool()方法得到的线程池，这是一个全局共享的线程池，如果有多种不同的任务都依赖该线程池进行处理，可能会导致资源争抢、代码阻塞等不确定的问题。所以建议针对每种任务，自定义线程池来处理，实现线程池资源的隔离
2.对于计算密集型任务(消耗CPU资源)，设置核心线程数为n+1或者n(n是CPU核心数)，可以充分利用CPU，多一个线程是为了可以在某些线程短暂阻塞或执行调度时，确保有足够的线程保持CPU繁忙，最大化CPU的利用率。
3.对于IO密集型任务(消耗1O资源)，可以增大核心线程数为CPU核心数的2-4倍，可以提升并发执行任务的数量。
4、并发编程可能会占用更多资源且带来不确定性（阻塞等），需要额外补异常（exceptionally）


异步任务：
1、立即执行：@Async注解/手动使用CompletableFuture
2、定时执行：爆破存在数据库中，通过Spring Scheduler任务定期扫描
3、消息队列任务分发：


中断恢复表
create table question_batch_status (
batch_id bigint primary key,
question_bank_id bigint,
total_questions int,
processed_questions int,
status varchar(20) -- running, completed, failed
);


缓存雪崩相关内容
https://zhuanlan.zhihu.com/p/346651831


项目启动流程
1、redis+mysql   服务器
2、es+kibama     进入对应下载目录
    .\bin\elasticsearch.bat
    .\bin\kibana.bat
3、hotkey work   启动hotkey项目